<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Yangzw</title>
    <link>blog.crazyyzw.top/tags/java/</link>
    <description>Recent content in Java on Yangzw</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 15 Jun 2022 21:29:01 +0800</lastBuildDate><atom:link href="blog.crazyyzw.top/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Quartz使用</title>
      <link>blog.crazyyzw.top/posts/quartz/</link>
      <pubDate>Wed, 15 Jun 2022 21:29:01 +0800</pubDate>
      
      <guid>blog.crazyyzw.top/posts/quartz/</guid>
      <description>Quartz是一个开源的作业调度框架，它完全由Java写成，并设计用于J2SE和J2EE应用中。
参考博客网址
一、Quartz基本配置 Quartz三大核心元素：Scheduler(调度器)、Trigger(触发器)、job(任务)。
通过Scheduler启动Trigger来执行job。
pom依赖：
&amp;lt;!--quartz相关依赖--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.quartz-scheduler&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;quartz&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.quartz-scheduler&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;quartz-jobs&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;gt;&amp;gt;&amp;gt;&amp;gt;SpringBoot替换为：&amp;gt;&amp;gt;&amp;gt;&amp;gt; &amp;lt;!--quartz依赖--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-quartz&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 在Quartz JAR文件的org.quartz包下就包含一个quartz.properties属性配置文件并提供了默认属性。如果需要调整默认配置，可以在类路径下建立一个新的quartz.properties，它将自动被Quartz加载并覆盖默认的设置。
配置信息如下：
#可以为任意字符串，对于scheduler来说此值没有意义，但是可以区分同一系统中多个不同的实例， #如果使用了集群的功能，就必须对每一个实例使用相同的名称，这样使这些实例“逻辑上”是同一个scheduler。 org.quartz.scheduler.instanceName = JobScheduler #可以是任意字符串，但如果是集群，scheduler实例的值必须唯一，可以使用AUTO自动生成。 org.quartz.scheduler.instanceId = AUTO org.quartz.scheduler.rmi.export = false org.quartz.scheduler.rmi.proxy = false # 默认false，若是在执行Job之前Quartz开启UserTransaction，此属性应该为true。 #Job执行完毕，JobDataMap更新完（如果是StatefulJob）事务就会提交。默认值是false，可以在job类上使用@ExecuteInJTATransaction 注解，以便在各自的job上决定是否开启JTA事务。 org.quartz.scheduler.wrapJobExecutionInUserTransaction = false #一个scheduler节点允许接收的trigger的最大数，默认是1，这个值越大，定时任务执行的越多，但代价是集群节点之间的不均衡。 org.quartz.scheduler.batchTriggerAcquisitionMaxCount=1 #线程池的实例类，（一般使用SimpleThreadPool即可满足几乎所有用户的需求） org.quartz.threadPool.class= org.quartz.simpl.SimpleThreadPool #线程数量，不会动态增加 org.quartz.threadPool.threadCount= 10 #线程优先级 org.quartz.threadPool.threadPriority= 5 #加载任务代码的ClassLoader是否从外部继承 org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread= true #是否设置调度器线程为守护线程 org.quartz.scheduler.makeSchedulerThreadDaemon: true #将schedule相关信息保存在RAM中，轻量级，速度快，遗憾的是应用重启时相关信息都将丢失。 #org.quartz.jobStore.class = org.quartz.simpl.RAMJobStore #最大能忍受的触发超时时间，如果超时则认为“失误” #org.</description>
    </item>
    
    <item>
      <title>MyBatis介绍及使用</title>
      <link>blog.crazyyzw.top/posts/mybatis/</link>
      <pubDate>Fri, 15 Apr 2022 18:30:23 +0800</pubDate>
      
      <guid>blog.crazyyzw.top/posts/mybatis/</guid>
      <description>一、什么是MyBatis？ MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。
1.MyBatis衍生工具 MyBatis-Plus：是一个MyBatis增强工具，在MyBatis的基础上只做增强不做改变，为简化开发、提高效率而生。
TkMyBatis：是基于 Mybatis 框架开发的一个工具，通过调用它提供的方法实现对单表的数据操作，不需要写任何 sql 语句，这极大地提高了项目开发效率。
2.MyBatis引入 1.可以通过下载mybatis的jar包置于类路径(classpath)中
2.单独使用MyBatis加入pom依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;x.x.x&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 3.集成SpringBoot中pom依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;x.x.x&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 二、MyBatis使用 简单使用配置可以通过输入流（InputStream）实现：
String resource = &amp;#34;&amp;lt;mybatis-config.xml的全限定名&amp;gt;&amp;#34;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder.build(inputStream); 也可以通过XML构建SqlSessionFactory：
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34; ?&amp;gt; &amp;lt;!DOCTYPE configuration PUBLIC &amp;#34;-//mybatis.org//DTD Config 3.0//EN&amp;#34; &amp;#34;http://mybatis.org/dtd/mybatis-3-config.dtd&amp;#34;&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;!--根据需要进行配置--&amp;gt; &amp;lt;/configuration&amp;gt; 不使用XML构建SQLSessionFactory:
DataSource dataSource = BlogDataSourceFactory.</description>
    </item>
    
    <item>
      <title>Stream常见用法</title>
      <link>blog.crazyyzw.top/posts/stream%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 12 Apr 2022 21:29:01 +0800</pubDate>
      
      <guid>blog.crazyyzw.top/posts/stream%E4%BD%BF%E7%94%A8/</guid>
      <description>匹配集合数据 boolean isFound = userList.stream().anyMatch(user -&amp;gt; Objects.equals(user.getId(), userId)); 过滤集合数据 List&amp;lt;UserDO&amp;gt; resultList = userList.stream() .filter(user -&amp;gt; Boolean.TRUE.equals(user.getIsSuper())) .collect(Collectors.toList()); 汇总集合数据 double total = accountList.stream().mapToDouble(Account::getBalace).sum(); 转化集合数据 List&amp;lt;UserVO&amp;gt; userVOList = userDOList.stream().map(this::transUser).collect(Collectors.toList()); 分组集合数据 Map&amp;lt;Long, List&amp;lt;UserDO&amp;gt;&amp;gt; roleUserMap = userDOList.stream() .collect(Collectors.groupingBy(UserDO::getRoleId)); 分组汇总集合 roleTotalMap = accountList.stream() .collect(Collectors.groupingBy(Account::getRoleId,Collectors.summingDouble(Account::getBalance))); 生成范围集合 int[] array1 = IntStream.rangeClosed(1,N).toArray(); int[] array2 = IntStream.iterate(1, n -&amp;gt; n*2).limit(N).toArray(); </description>
    </item>
    
  </channel>
</rss>
