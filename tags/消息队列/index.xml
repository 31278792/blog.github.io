<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>消息队列 on Yangzw</title>
    <link>/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link>
    <description>Recent content in 消息队列 on Yangzw</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 04 Sep 2022 20:33:10 +0800</lastBuildDate><atom:link href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>消息队列比较</title>
      <link>/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%AF%94%E8%BE%83/</link>
      <pubDate>Sun, 04 Sep 2022 20:33:10 +0800</pubDate>
      
      <guid>/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%AF%94%E8%BE%83/</guid>
      <description>什么是消息队列 Message Queue(MQ)的目的是用于通讯，屏蔽底层复杂通讯协议，而是利用更高层次通讯模型——生产者/消费者模型。通过定义两个对象，一个作为生产者，负责发送数据，另一个作为消费者，负责接收数据。我们可以根据SDK来定义自己的生产者和消费者实现消息通讯而不用去管底层通讯协议具体实现。
为什么使用消息队列 解耦：消息队列作为中间件起到了解耦的作用，降低了系统耦合性。 异步：消息队列采用异步的方式，将消息暂存入队列中等待消费，提供了响应速率。 削峰：当并发量过大时，可以在这期间积压数据在消息队列中，供数据库按照自身处理速率，慢慢拉取队列消息。 消息队列带来的风险 系统可用性降低：当消息队列服务挂了，我们系统项目集成了消息队列，即使项目没任何问题，也会导致不能正常运行。 系统复杂性提高：消息队列将增加我们的开发难度，在开发中会涉及到一致性问题、如何避免消息重复消费，如何保证可靠的消息传输等，大大增加了系统复杂度。 消息队列选型 我们通过表格直观展示各消息队列的差异分析：
MQ Kafka ActiveMQ RabbitMQ RocketMQ 开发语言 Java&amp;amp;Scala Java Erlang Java 单机吞吐量 十万级 万级 万级 十万级 消息延迟 ms级以内 ms级 us级 ms级 消息丢失 参数优化配置后可做到0丢失 有较低概率丢失 有较低概率丢失 参数优化配置可做到0丢失 可用性 非常高（分布式架构） 高（主从架构） 高（主从架构） 非常高（分布式架构） 使用场景 日志等海量数据流 DB数据同步，高堆积离线消息处理 非海量高可靠场景，企业级应用，分布式事务（XA），异构系统整合 非海量高可靠性场景，大规模企业应用，ESB 复杂路由策略，异构系统整合 应用于电商、订单、金融等分布式应用领域 总结 只支持主要的MQ功能，像一些消息查询，消息回溯等功能没有提供，更偏重于流式数据批处理。 成熟的产品，在很多公司得到应用；有较多的文档；各种协议支持较好 基于erlang开发，所以并发能力很强，性能极其好，延时很低;管理界面较丰富 MQ功能比较完备，扩展性佳 如果消息队列不是将要构建系统的重点，对消息队列功能和性能没有很高的要求，只需要一个快速上手易于维护的消息队列，建议使用 RabbitMQ。
如果系统使用消息队列主要场景是处理在线业务，比如在交易系统中用消息队列传递订单，需要低延迟和高稳定性，建议使用 RocketMQ。
如果需要处理海量的消息，像收集日志、监控信息或是埋点这类数据，或是你的应用场景大量使用了大数据、流计算相关的开源产品，那 Kafka 是最适合的消息队列。</description>
    </item>
    
  </channel>
</rss>
