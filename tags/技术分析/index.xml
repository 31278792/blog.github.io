<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术分析 on Yangzw</title>
    <link>blog.crazyyzw.top/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/</link>
    <description>Recent content in 技术分析 on Yangzw</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 31 Aug 2022 19:29:59 +0800</lastBuildDate><atom:link href="blog.crazyyzw.top/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>实现电子签名涉及哪些步骤？</title>
      <link>blog.crazyyzw.top/posts/%E7%94%B5%E5%AD%90%E7%AD%BE%E5%90%8D%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Wed, 31 Aug 2022 19:29:59 +0800</pubDate>
      
      <guid>blog.crazyyzw.top/posts/%E7%94%B5%E5%AD%90%E7%AD%BE%E5%90%8D%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B/</guid>
      <description> 签名者身份确认：首先需要确认签名者的身份，确认签名者的身份可以通过各种方式实现，比如用户账号、身份证号码、手机号码等。 签名生成：签名生成过程中，需要通过加密算法生成签名值，保证签名的不可伪造性和不可篡改性。 签名验证：签名验证是指在签署电子合同时，需要对签名者身份进行验证，同时对签名值进行验证，以确保签名的有效性和完整性。 存证：存证是指将签名信息存储到可信的存证平台上，以便后续的证明和追溯。 </description>
    </item>
    
    <item>
      <title>消息队列比较</title>
      <link>blog.crazyyzw.top/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%AF%94%E8%BE%83/</link>
      <pubDate>Wed, 31 Aug 2022 19:29:59 +0800</pubDate>
      
      <guid>blog.crazyyzw.top/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%AF%94%E8%BE%83/</guid>
      <description>什么是消息队列 Message Queue(MQ)的目的是用于通讯，屏蔽底层复杂通讯协议，而是利用更高层次通讯模型——生产者/消费者模型。通过定义两个对象，一个作为生产者，负责发送数据，另一个作为消费者，负责接收数据。我们可以根据SDK来定义自己的生产者和消费者实现消息通讯而不用去管底层通讯协议具体实现。
为什么使用消息队列 解耦：消息队列作为中间件起到了解耦的作用，降低了系统耦合性。 异步：消息队列采用异步的方式，将消息暂存入队列中等待消费，提供了响应速率。 削峰：当并发量过大时，可以在这期间积压数据在消息队列中，供数据库按照自身处理速率，慢慢拉取队列消息。 消息队列带来的风险 系统可用性降低：当消息队列服务挂了，我们系统项目集成了消息队列，即使项目没任何问题，也会导致不能正常运行。 系统复杂性提高：消息队列将增加我们的开发难度，在开发中会涉及到一致性问题、如何避免消息重复消费，如何保证可靠的消息传输等，大大增加了系统复杂度。 消息队列选型 我们通过表格直观展示各消息队列的差异分析：
MQ Kafka ActiveMQ RabbitMQ RocketMQ 开发语言 Java&amp;amp;Scala Java Erlang Java 单机吞吐量 十万级 万级 万级 十万级 消息延迟 ms级以内 ms级 us级 ms级 消息丢失 参数优化配置后可做到0丢失 有较低概率丢失 有较低概率丢失 参数优化配置可做到0丢失 可用性 非常高（分布式架构） 高（主从架构） 高（主从架构） 非常高（分布式架构） 使用场景 日志等海量数据流 DB数据同步，高堆积离线消息处理 非海量高可靠场景，企业级应用，分布式事务（XA），异构系统整合 非海量高可靠性场景，大规模企业应用，ESB 复杂路由策略，异构系统整合 应用于电商、订单、金融等分布式应用领域 总结 只支持主要的MQ功能，像一些消息查询，消息回溯等功能没有提供，更偏重于流式数据批处理。 成熟的产品，在很多公司得到应用；有较多的文档；各种协议支持较好 基于erlang开发，所以并发能力很强，性能极其好，延时很低;管理界面较丰富 MQ功能比较完备，扩展性佳 如果消息队列不是将要构建系统的重点，对消息队列功能和性能没有很高的要求，只需要一个快速上手易于维护的消息队列，建议使用 RabbitMQ。
如果系统使用消息队列主要场景是处理在线业务，比如在交易系统中用消息队列传递订单，需要低延迟和高稳定性，建议使用 RocketMQ。
如果需要处理海量的消息，像收集日志、监控信息或是埋点这类数据，或是你的应用场景大量使用了大数据、流计算相关的开源产品，那 Kafka 是最适合的消息队列。</description>
    </item>
    
    <item>
      <title>外键的使用场景</title>
      <link>blog.crazyyzw.top/posts/%E6%95%B0%E6%8D%AE%E5%BB%BA%E8%A1%A8%E5%A4%96%E9%94%AE%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6/</link>
      <pubDate>Wed, 24 Aug 2022 19:01:52 +0800</pubDate>
      
      <guid>blog.crazyyzw.top/posts/%E6%95%B0%E6%8D%AE%E5%BB%BA%E8%A1%A8%E5%A4%96%E9%94%AE%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6/</guid>
      <description>1.互联网行业：不推荐使用外键。
1.用户量大，并发度高，为此数据库服务器很容易成为性能瓶颈，尤其受IO能力限制，且不能轻易地水平扩展
2.若是把数据一致性的控制放到事务中，即让应用服务器承担此部分的压力
3.应用服务器一般都是可以做到轻松地水平的伸缩
2.传统行业：可以使用。
1.软件应用的人数有限，换句话说是可控的
2.数据库服务器的数据量也一般不会超大，且活跃数据有限</description>
    </item>
    
    <item>
      <title>进程、线程、协程三者区别</title>
      <link>blog.crazyyzw.top/posts/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Mon, 18 Jul 2022 21:09:12 +0800</pubDate>
      
      <guid>blog.crazyyzw.top/posts/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/</guid>
      <description>进程 进程是操作系统资源分配的最小单元，它拥有独立的地址空间、独立的内存和数据栈，其间通信需要通过进程间通信（IPC）机制。
线程 线程是进程的执行单元，一个进程可以有多个线程，它们共享进程的地址空间和数据栈，但是每个线程都有自己的执行栈和程序计数器。线程之间可以通过共享内存等方式直接通信，同时也可以通过互斥锁、信号量等机制实现同步和互斥。
协程 协程是一种轻量级的线程，也可以称为协作式多任务。协程与线程类似，但是它们的调度和切换不是由操作系统控制，而是由程序自身控制。协程的数据和栈都在程序的堆上分配，不会像线程一样占用操作系统的资源。因此，协程的创建和销毁非常快，切换也非常高效，可以大大提高程序的并发性和吞吐量。协程的主要作用是在单线程内实现并发，解决传统多线程并发编程中的线程切换、锁竞争等问题，同时也可以用于实现异步编程、事件驱动等场景。在Python、Go、Lua等语言中，协程已经成为了非常重要的编程范式，被广泛用于网络编程、高性能计算等领域。</description>
    </item>
    
    <item>
      <title>软件开发各版本含义</title>
      <link>blog.crazyyzw.top/posts/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%89%88%E6%9C%AC/</link>
      <pubDate>Fri, 01 Jul 2022 18:33:29 +0800</pubDate>
      
      <guid>blog.crazyyzw.top/posts/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%89%88%E6%9C%AC/</guid>
      <description>Alpha版本 处于软件开发过程初期阶段，通常只提供内部测试或部分用户测试使用，存在较多问题和漏洞。
Beta版本 处于软件开发过程中期阶段，软件功能基本全部实现，但仍存在一些问题和漏洞，此时通常会向广泛的用户群体发布测试版本，以收集反馈和改进软件。
RC版本 处于软件开发过程后期阶段，软件功能不再存在较大变动，此时会发布该候选版本（Release Candidate, 简称RC），并通过测试和反馈来进一步优化和改进软件。
正式版本 软件发布前的最终版本，此时软件已经通过多轮测试，并修复了各种问题和漏洞，通常是最稳定和可靠的版本。
版本号命名规则：常见的版本号包括三位或四位数字，例如1.0.0或1.0.0.0，其中第一位表示主版本号，第二位表示次版本号，第三位表示修订号或补丁号。</description>
    </item>
    
    <item>
      <title>系统架构需要考虑哪些方面？</title>
      <link>blog.crazyyzw.top/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Mon, 20 Jun 2022 20:29:02 +0800</pubDate>
      
      <guid>blog.crazyyzw.top/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</guid>
      <description> 业务需求：需要考虑业务需求，以确定架构的范围和功能，以及架构的可扩展性。 技术选型：需要考虑技术选型，以确定架构的技术架构，以及技术的可扩展性。 架构设计：需要考虑架构设计，以确定架构的组件、模块、接口、数据库等，以及架构的可维护性。 性能优化：需要考虑性能优化，以确定架构的性能指标，以及架构的可优化性。 安全性：需要考虑安全性，以确定架构的安全措施，以及架构的可安全性。 </description>
    </item>
    
  </channel>
</rss>
